---
title: "우리는 SPRING에서 UNIT TEST를 잘 작성하고 있는가?"
categories:
    - java
    - spring
    - test
last_modified_at: 2022-03-07T02:47:00
toc: true
toc_sticky: true
---

자다가 오늘 공부 내용을 정리하다가 까먹기 전애 글로 남겨야겠다고 생각해서 새벽 3시에 작성한 글이라 정리가 많이 필요할 것 같다.

# JAVA TEST

여기서는 단위 테스트만 가지고 이야기 해보고자 한다. 

# TEST 란

자신이 작성한 비즈니스를 테스트 하기위해 작성하는 것이 보통이고 그렇게 사용하고 있다. 그렇다면 단위 테스트란 무엇인가 아주 작은 단위의 테스트를 말한다.
그렇다면 작은 테스트란 무엇인가?

`1 + 2 = 3`

마치 위 공식처럼 아주 단순한 테스트를 하는 것이 단위 테스트라고 말하고 싶다.

그렇다면 SPRING에서 단위 테스트는 잘 작성되고 있는가?

# SPRING에서 TEST

보통 스프링 테스트를 작성하면 클레스 위에 어노테이션을 붙이고 시작한다.

```java
@RunWith(SpringRunner.class)
public class TestClass {
    ...
}
```

그런데 가만히 잘 생각해보자. 우리가 작성하는 테스트에 스프링이 과연 필요한가?

1 + 2 = 3 라는 단위 테스트에 빚대어 살펴보자.
어떤 값(1)에 어떤 값(2)를 더했더니(+) 어떤 값(3)이 나왔다.
이 안에서 스프링이 사용되는 곳이 있을까? 스프링이 필요하지 않는다. 들어갈 구멍도 없어보인다.

비유가 너무 극단적인가 그럼 객체로 바꿔보자.

## TEST 객체

```java
class B {
    ...
    fn(A a) {
        ...
        return c;
    }
}
```

이정도 코드면 비슷해 보일 것이다.
내가 테스트할 영역을 풀어서 설명해보자.
A라는 객체를 B라는 객체의 fn에 넣으면 결과값으로 객체 c를 얻는다.

이렇게 설명하면 위 1 + 2 = 3과 비슷해 보이지 않은가?
여기서 스프링이 사용되는 곳이 있을까?
좀더 명확하게 하기위해 테스트 코드까지 작성해보자.

```java
public class TestClass {
    @Test
    public UNIT_TEST() {
        //given
        A a = new A();
        B b = new B();

        //when
        C c = b.fn(a);

        //then
        assert c;
    }
}
```

아마도 위처럼 작성할 것이다.

여기서 스프링이 사용되는 곳이 있을까? 어쩌면 내가 너무 내 주장에만 맞도록 코드를 작성한 것처럼 보일 수 있겠다. 다음과 같이 수정해보자.

## 일반적(?)으로 작성된 코드

```java
//생략
class C {
    public final X x;
    public final Y y;

    public fn(A a) {
        ...
        return c;
    }
}

public class TestClass {
    @Autowired
    public B b;

    @Test
    public UNIT_TEST() {
        //given
        A a = new A();

        //when
        C c = b.fn(a);

        //then
        assert c;
    }
}

```

이러면 좀더 평소에 작성하던 코드와 비슷해 보인다.
수정한 부분은 C에 생성자 주입(Constructor based Injection)을 통해 객체 X와 Y를 넣어주었다.
테스트 코드에 B를 필드로 빼서 주입받도록 수정하였다.

이제 다시 살펴보자 스프링이 사용되는 곳이 있을까? 좀 햇갈리 지도. 찬찬히 살펴보자.

먼저 하려고 하는 것만 생각하면, 우리는 단위 테스트를 해야한다.
단위 테스트는 무엇인가 아마도 `fn`이 될 것이다.
그러면 단위 테스트에서 존재하는 객체는 무엇인가?
그건 A, B, C 그리고 아마도 사용할 수도 있고 아닐 수도 있는 X와 Y가 있겠다.

각 객체는 이 행위(혹은 단위)에서 어떤 행위를 하고 있는가?(스프링이 사용되는 곳이 있을까?)
객체 A는 우리가 테스트 하려고 만든 값이고 객체이다. 여기서 스프링이 끼여들 곳은 없어보인다.
객체 B는 테스트를 하려고 하는 영역 즉 fn을 가지고 있는 객체이다. 확실한 것은 fn은 내가 만들었고 내가 테스트하고 싶은 단위이다. 일단은 여기까지만 정의하고...
객체 C는 테스트 결과물이다. 이것은 어떤 값을 수도 있고 exception 일 수 있지만 내가 예측하고자 하는 것은 확실하다. 즉 스프링이 만들어준 것은 아니다.

일단 여기까지 A와 C는 스프링이 들어갈 공간은 보이지 않는다.

그럼 B를 마저 확인해보자.

여기서 확인할 것은 우리는 B를 테스트하는 것인가 B가 가진 fn을 테스트하는 것인가 이다.

내 생각은 fn을 테스트하는 것이 맞다고 생각한다. 즉 테스트하고자 하는 단위는 fn 이다.

하지만 B는 스프링이 주입해준 것이라고 생각할 수도 있을 것 같다.

## B는 스프링이 주입한 객체인가?

우리가 테스트를 하면 많이 격는 에러 메시지중에 가장 많이 보는 것이 아마 이것이 아닐까 한다.

`Error creating bean with name '무언가': Unsatisfied dependency expressed through field '무언가'; ...`

bean이 없습니다. 혹은 NullPointerException. 결국은 객체가 없다는 것인데 스프링 테스트를 사용하는 `@RunWith(SpringRunner.class)`을 사용하면 대체로 고쳐지긴 한다. (하지만 절대로 모든 경우에서 고쳐지는 것도 아니고 설정 또는 프로필 또는 환경에 따라서 런타임에서 에러가 가는 경우도 많다.) 그렇다면 B를 주입받기 위해 배경을 스프링으로 만들어야 할까?

우리는 우리가 작성한 fn을 테스트하는 것이지 스프링이 B를 잘 주입했는가 테스트하는 것이 아니다. 결국 fn만 신경쓰면 된다.
그런데 문제가 있다. fn을 테스트하기 위해선 객체 B가 필요한데 객체 B는 객체 X와 Y에 의존적이다. fn에 사용할지 않할지도 모르는 X와 Y를 신경쓰기 위해 스프링을 사용해야하는 것인가?

나는 절대로 아니라고 생각한다. 왜냐면 C를 만들때 가짜 X와 가짜 Y를 주면 fn을 사용할 수 있다. 결국 원하는 것은 fn이다.

```java
public class TestClass {
    @Mock
    public X x;

    @Test
    public UNIT_TEST() {
        //given
        Y y = new Y();
        C c = new C(x, y);

        A a = new A();

        //when
        C c = b.fn(a);

        //then
        assert c;
    }
}
```

이렇게 객체 Y를 만들거나 가짜 객체 X인 `Mock`을 만들면 C를 만드는데 전혀 문제가 없다. 

다시 처음 질문으로 테스트를 하는데 스프링이 필요한가? 이런 의문이 들 수 있다. fn에서 X 혹은 Y가 사용될 수도 있는 것 아닌가? 가짜 객체를 주입하면 정상적인 테스트를 할 수 없는 것 아닌가.

## 모든 것은 단위

이렇게 생각하는 것이 가능하다. 그럼 이렇게 생각해보자. X와 Y는 왜 존재하고 누가 만든 것 인가?

`필요에 의해 스프링 객체를 쓴것이 아니라면` X도 어떤 비즈니스때문에 내가 만들었고, Y역시 사람이 만들었다.

그렇다면 fn에서 X가 어떤 역활을 해야한다면 그 역활은 무엇인가?

아마 fn과 다를 것이 없겠다. 왜냐면 객체 X에서 사용하는 것은 객체 X의 어떤 역활 즉 x가 가지고 있는 어떤 `fn2`(즉 x.fn())이 될 것이다. 정상적인(테스트를 마친) X라면 fn2는 우리가 원하는 결과를 에상할 수 있다.(이미 검증이 되었다.)

그러면 다음과 같이 작성해도 문제가 없지 않을까?

```java
public class TestClass {
    @Mock
    public X x;

    @Befroe
    public void init() {
        D d = new D();
        Mockito.when(x.fn2()).thenReturn(d);
    }

    @Test
    public UNIT_TEST() {
        //given
        Y y = new Y();
        C c = new C(x, y);

        A a = new A();

        //when
        C c = b.fn(a);

        //then
        assert c;
    }
}
```

처리방법이야 다양하겠지만 결론은 하나다. 가짜 결과물(역양이 이상할뿐 정상적인 데이터이다.)을 주면된다. 위 X는 검증이된 객체이고 결과물도 예측이 가능하다. 그러면 가짜 결과물을 주면된다. 그러면 그 결과물을 받은 C의 fn은 알아서 처리할 것이고 우리는 그 처리과정이 맞는지 테스트만 하면된다.

## 객체지향 설계

다시 처음으로 돌아와서 여기에 스프링이 사용되었는가? 사실 여기까지 작성해도 우리는 에러르 많이 접할 것이다. 그리고 어쩔 수 없이 좌절하고 "역시 스프링이야"를 외치면서 `@RunWith`을 붙일 것이다.

아마 그건(전적으로 내 생각이면서 혹은 경험이면서) 이미 잘못된 설계를 하고 있었다고 생각한다. 어떤 설계를 잘못했는가 물어본다면. 그건 우리 모두가 알고 있고 객체지향을 공부하면서 귀에 닳도록 읽은 `의존성`이라는 녀석 때문일 것이다.

에러가 난 원인을 생각해보자.

분명이 이 단위(fn)에서 사용되는 객체는 A, B, C 또는 X, Y이다. X와 Y가 검증되었다고 하지만 사실 X와 Y도 누군가를 필요로하는 객체일 수 있다. 결국 B는 X에게 X는 또 누군가에게 누군가는 누군가에게 또 누군가는 누군가에게 엃히고 설킨이 더러운(?) 의존성 때문에 단위 테스트한번 못하고 스프링을 킬 수밖에 없게 된다.

결국 의존성을 없애야 한다. 결국 우리가(내가) 짠 코드는 의존성 투성이의 코드인 것이다.

## 의존성을 자르자

의존성을 자르는 방법은 더 좋은 블로그 어 좋은 책을 참조하면 엄청 머리 좋은 사랑들이 정리해 놓았기 때문에 여기서 자세히 작성할 필요는 없겠지만!!

이렇게 문제만 내고 끝내는 것은 똥을 싸고만 기분이기 때문에 팁(?)은 아니고 내가 자주 사용하는 방법을 하나 소개하면

많은 개발자들이 의존성을 끊기위해 많은 고민을 해왔고 그러면서 객체지향 원칙 또는 디자인 패턴 등  많은 방법이 나왔다. 사실 나는 객체지향 원칙은 맨날 까먹고 디자인 패턴 이름도 모르면서 사용해왔다.

그런데 이것만 알면 나도 모르는세에 원칙도 지키면서 나도 모르는 디자인 패턴을 사용하게 되는게 바로 `interface`이다.

## 인터페이스

(꼭 그렇지 않지만)객체 사이에 인터페이스를 붙이면 자연스럾게 관계가 떨어지는 현상을 발견할 수 있다. 처음에는 모르고 다른 그렇게 쓰고 그렇게 배웠으니까 interface를 만들고 그에 따른 impl을 만들었다. 왜 귀찮게 그냥 객체로 만들면 스프링이 알아서 주입해 줄텐데 귀찮게 파일을 2개나 만드는 것인가 function 이라도 추가하면 2개다 수정하는게 여간 귀찮은게 아닌데 왜 그렇거지 하면서 불평을 했는데.

이 때는 안하고 넘어간 것이 있었다.

바로 `TEST` 였다. 그렇다 테스트를 하지않고 그냥 개발(사실 개발도 아니다)을 하면 객체관의 관계가 긴밀해지고 의존성이 커지는 것이었다.

단위 테스트만 작성해도 자연스럽게 의존성이 없어지는 것인데 언제부턴가 테스트는 하지않고 그러다 누군가가 테스트 코드 작성하라고 하니까 그때 작성해보니 의존성 투성이에 스프링을 강제로 실행할 수 밖에 없는 상태가 되고 결국에는 스프링에서 테스트는 스프링이 꼭 있어야만하는 존재로 여기게(자기합리, 자기만족, 정당화)된 것은 아니까 반성해본다.

# 결론

그래서 결론은

`단위 테스트 제대로 알고 작성하자`

