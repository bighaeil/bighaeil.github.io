---
title: "MySQL 스터디 4일차 - index"
categories:
    - db
    - mysql
    - index
last_modified_at: 2023-06-07T22:00:00
toc: true
---

인덱스는 데이터베이스 쿼리의 성능에 중요한 부분이다

쿼리 성능은 디스크에서 데이터를 가져오거나 쓰는 행위를 줄여주는 것을 의미한다

그래서 디스크 I/O를 잠시 알아보자

디스크 I/O는 컴퓨터에서 가장 느린 부분이다

디스크에는 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)가 있다

SSD는 HDD보다 랜덤 I/O가 휠씬 빠르다

데이터베이스 서버에서 순차 I/O 작업보다 랜덤 I/O를 통해 데이터를 읽고 쓴느 작업이 데부분이다
그래서 SSD가 DBMS 스토리지에 최적이다

랜덤 I/O는 보통 디스크(원판)에 헤더를 원하는 위치에 이동하는 것을 의미한다 그런데 그 위치가 물리적으로 불연속으로 헤당 위치로 움직여야 한다

순차 I/O는 랜덤 I/O처럼 이동하는 것은 같지만 데이터가 연속적이여서 그대로 쭉 읽으면 된다

일반적으로 쿼리 튜닝하는 것은 이런 랜덤 I/O 자체를 줄이는 것을 목적으로 한다

즉 쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 쿼리를 개선한다

# 인덱스

인덱스는 색인이라는 의미로 DB에서는 해당 레코드가 저장된 주소와 데이터를 빠르게 찾을 수 있도록 만들어 두는 것이다

DBMS의 인덱스는 값으로 항상 정렬된 상태를 유지한다

그래서 INSERT, UPDATE, DELETE에는 처리가 느리지만 정렬된 인덱스는 SELECT가 빠르게 처리된다

그래서 WHERE 조건절에 사용하는 칼럼을 전부 인덱스로 생성하면 저장 성능이 떨어지고 인덱스가 비대해져 성능이 떨어진다

인덱스를 역할별로 구분

- 프라이머리 키(Primary key), 레코드를 대표하는 칼럼 값으로 만들어진 인덱스, NULL 값을 허용하지 않고 중복을 허용하지 않는다

- 프라이머리 키를 제외한 나머지 모든 인덱스 보조 키(Secondary Index)

인덱스를 알고리즘으로 구분

- B-Tree 알고리즘, 일반적으로 사용, 값을 변형하지 않고 그대로 인덱싱

- Hash 인덱스 알고리즘, 값을 해시값으로 인덱싱, 빠른 검색을 지원, 값이 변행되므로 부분 검색 사용할 수 없음, 주로 메모리 기반의 데이터베이스에서 사용

## B-Tree 인덱스

일반적으로 사용

B는 Balanced를 의미

원래 값을 변형시키지 않음

항상 정렬된 상태로 유지

### 구조 및 특징

트리 구조로 최상위 하나의 루트 코드(Root node)가 존재

가장 하위에 있는 노드를 리프 노드(Leaf node), 중간의 노드를 브랜치 노드(Beanch node)라 한다

인덱스는 정렬되어 있지만 레코드는 정렬되지 않는다

리프 노드의 데이터 파일은 저장된 레코드의 주소를 가진다

InnoDB 스토리지 엔진은 레코드를 읽기 위해서

검색어를 인덱스 키로 하고 프라이머리 키를 값으로 하는 B-Tree 인덱스를 검색하고

검색어를 프라이머리 키로 하고 레코드를 값으로하는 B-Tree 인덱스를 다시 검색하는 구조를 하고 있다

#### 인덱스 키 추가

인덱스를 추가하려면 리프 노드를 추가해야 하는데 해당 리프 노드가 꽉 차서 더는 저장할 수 없으면 분리(Split)해야 한다 이는 상위 브랜치 노드까지 처리 범위가 넓어지기 때문에 비용이 많이 든다

#### 인덱스 키 삭제

삭제는 해당 키 값이 저장된 리프 노드를 그냥 삭제하면 된다

#### 인덱스 키 변경

변경은 값이 변경되어 해당 리프 노드 위치가 변경되야 한다

변경 작업은 먼저 키를 삭제하고 변경된 값을 추가 한다

#### 인덱스 키 검색

검색은 로트 노드부터 시작하여 브랜치 노드를 거쳐 리프 노드까지 이동하는 작업을 한다 이를 트리 탐색 이라 한다

### 영향

인덱스 사용에 영향을 주는 요소

#### 인덱스 키 값의 크기

InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지(Page) 또는 블록(Block)이라 한다

즉 디스크 읽기, 쓰기 작업의 최소 작업 단위가 된다

페이지는 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이다

그래서 인덱스도 페이지 단위로 관리된다

그래서 B-Tree의 자식 노드를 몇 개까지 가지는지 페이지 크기에 따라 결정된다

B-Tree의 B는 binary 가 아니다 즉 여러 자식 노드를 가질 수 있다

인덱스를 구성하는 키 값이 커지면 디스크로 부터 읽는 횟수가 늘어나고 그만큼 느려진다

#### 깊이

깊이(Depth)는 제어할 수 없다

하지만 인덱스 키 값의 크기가 깊이에 영향을 미친다

인덱스 키 값이 커지면 페이지에 담을 수 있는 인덱스 키 값의 개수가 적어지기 때문에 깊이가 깊어진다

#### 선택도(기수성)

선택도(Selectivity) 또는 기수성(Cardinality)는 유니크한 값의 수를 의미한다

전체 인덱스 키 값이 100개에서 유니크한 값이 10개라면

기수성은 10 이다

중복된 값이 많아지면 기수성은 낮아지고 선택도는 떨어진다

선택도가 높을 수록 검색 대상이 줄어들기 때문에 빠르게 처리한다

#### 읽어야 하는 레코드 수

만약 거의 모든 테이블을 읽어야 한다면 인덱스를 거치는 것 보다 직접 레코드를 읽는 것이 효율적이다

즉 인덱스를 이용할지 직접 읽을지 판단해야 한다

인덱스를 통해 읽어야할 레코드 수가 전체 테이블 레코드의 20 ~ 25% 면 인덱스를 이용하지 않고 테이블을 직접 읽는 것이 효율적이다




