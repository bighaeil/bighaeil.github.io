---
title: "DAY 1 - object & design"
categories: 
  - oop
tags:
  - oop
  - object
  - design
  - review
last_modified_at: 2020-09-30T20:10:00+09:00
toc: true
toc_sticky: true
---

# 이론과 실무

IT 일을 하면서 느끼는 것 - 일 중심의 업무와 개발 중심의 업무에서 고민을 많이 한다.

일 중심 - 아무래도 빨리 끝낼 수 있기 때문에

개발 중심 - 테스트 코드, 리펙토링 등 의미없어 하는 회사들도 많다.

하지만 책에서 가장 마음에 와닿는 말이 있었다.

> 해당 분야가 충분히 성숙해지는 시점에 이르러서야 이론이 실무를 추월하게 된다.

우리가 일보다 "어떻게 만들까"에 집중하게된 이유는

이론이 충분히 성숙 -> 실무의 더 많은 도움

이라 생각한다.

그냥 일하는 것도 충분한 이론이 밑바탕에 있어야 더 효율적으로 일하게 된다는 사실을 알게 되었다.

즉 개인이 이론적인 성숙이 있어야 한다는 것을 말한다.

# 설계

설계란 무엇인가

업무에서 많이 설계하는 판매에 대해서 예를 들어보자.

## 티켓 판매

티켓을 판매하는 상황을 보자.

티켓이 있겠고
```java
class 티켓 {
  private 요금

  public 얼마인가요()
}
```

관람객이 있겠다.
```java
class 관람객 {
  private 가방

  public 뭐가있지()
}
```

관람객은 가방에는 돈, 초대장, 티켓이 있겠다.
```java
class 가방 {
  private 돈
  private 초대장
  private 티켓

  public 초대장이_있으면()
  public 초대장을_준다()
  public 돈을_지불()
  public 티켓을_받음()
}
```

티켓을 살 수 있는 매포소에는
```java
class 매표소 
  private 돈
  private 티켓바구니

  public 돈을_수납()
  public 티켓을_지급()
```

매표소에는 판매원이 일을 하고 있다.
```java
class 판매원
```

그래서 극장에서는 이런 일이 일어난다.
```java
class 극장 {
  private 판매원

  public 입장(관람객)  {
    if (관람객.가방.초대장이_있으면()) {
      관람객.가방.초대장을_준다();
    } 
    else {
      관람객.가방.돈을_지불();
      판매원.매표소.돈을_수납();
      판매원.매표소.티켓을_지급();
      관람객.가방.티켓을_받음();
    }
  }
}
```


### 수동적인 존재

> 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재

모든 일은 극장에서 일어난다. 관람객과 판매원의 의사와 상관없이 돈을 빼고 티켓을 준다.

수동적인 존재의 원인으로  

하나의 메서드에서 너무 많은 일이 일어난다.

(사실 코드가 이상하지만) 이런 코드는 코드를 더 이해하기 어렵게 만든다.


### 변경에도 취약한 코드

관람객이 가방이 아니라 지갑을 거낸다면?

돈이 아니라 카드로 지불한다면?

객체를 변경하면 수정해야 될 부분들이 너무 많다.

객체 사이의 관계가 얼마나 긴밀하게 연결되어 있는가를

> 객체 사이의 의존성(dependency)

의존성이 과한 경우 `결합도(coupling)`가 높다고 말한다.

객체 사이의 의존선을 없애라는 말이 아니다. 객체지향 설계에 가장 중요한 점은 객체간의 의존성을 생각하면서 `협력`하게 만드는 것이다.


## 개선

관람객과 판매원을 자율적인 존재로 만든자.

먼저 판매원이 자율적으로 판매를 할 수 있도록 해보자.

```java
class 판매원 {
  private 매표소

  public 판매한다(관람객) {
    if (관람객.가방.초대장이_있으면()) {
      관람객.가방.초대장을_준다();
    } 
    else {
      관람객.가방.돈을_지불();
      매표소.돈을_수납();
      매표소.티켓을_지급();
      관람객.가방.티켓을_받음();
    }
  }
}
```

```java
class 극장 {
  private 판매원

  public 입장(관람객)  {
    판매원.판매한다(관램객);
  }
}
```

이거 극장에서 판매원으로 코드만 이동한 것 아니야?  
판매원만 고생하게 생겼네 라고 생각할 수 있지만...

매표소를 확인해보자.  
이제 매표소는 판매원 외에는 누구도 확인할 수 없다.  
악의적으로 매표소를 털거나 티켓을 훔치거나 (판매원이 사기치지 않는다면) 할 수 없다.
즉 제 3자가 매표소를 이렇게 저렇게 할 수 없다는 의미이다.  

> 이처럼 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 `캡슐화(encapsulation)`라 부른다.

극장 입장에서 보면 

극장은 단지 판매원의 `판매한다()`를 통해 메시지를 이해하고 응답할 수 있다는 사실이다.  
즉 극장은 판매원의 `인터페이스(interface)`에만 의존한다.  
즉 판매원의 매표소는 `구현(implementation)` 영역에 속한다.

> 객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드로 만든다.

