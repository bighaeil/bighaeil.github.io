---
title: "CHEPTER 3 - movie in oop"
categories: 
  - oop
tags:
  - oop
  - object
  - review
  - inheritance
  - abstraction
last_modified_at: 2020-10-03T20:00:00+09:00
toc: true
toc_sticky: true
---

# 객체지향 프로그래밍 

(1장을 하면서 느낀점은 최대한 책의 내용을 인용하려고 하지 않으려고 하는데 정의나 사용하는 말이 아무래도 비슷하고 이미 책을 읽고 적으려니 머리속에서 글이 맴돈아 정리하기가 쉽지 않다.)  

2장은 영화 예메 할인을 통해서 객체지향 프로그래밍을 알아본다.  
요약하자면 상속과 다형성을 간단히 살펴본다.

2장을 살펴보자.  


# 영화 예메 시스템

영화 예메 시스템에 대한 기본적인 정보와 용어 정리는 그냥 넘어자.

## 할인

요금에 대한 할인에 대한 정의

- 할인 조건(discount condition)
  - 순서 조건(sequence condition) : 첫 상영되는 영화 또는 10번째 상영되는 영화
  - 기간 조건(period condition) : 조조 할인 등
- 할인 정책(discount policy)
  - 금액 할인 정책(amount discount policy) : 일정 금액 할인
  - 비율 할인 정책(percent discount policy) : 비율 요금 할인

물론 할인 정책은 비선택 가능, 중복 가능 이다.

## 영화

| 영화 | 할인 정책 | 할인 조건 |
|:---|:---|:---|
| 아바타 (가격: 10,000원) | 금액 할인 정책 (할인액: 800원) | 조조, 10회, 기간 등 |
| 타이타닉 (가격: 11,000원) | 금액 할인 정책 (할인율: 10%) | 2회, 기간 등 |
| 스타워즈 (가격: 10,000원) | 없음 | 없음 |

예제를 위한 배경설정은 끝났고 이제 설계를 진행해보자.


# 설계

설계를 진행하기 앞서 객체지향 프로그래밍을 다시 확인하자.

어떤 `클래스(class)`를 필요한지 고민하기 전에

> 어떤 객체들이 필요한지 고민하라.

> 객체는 홀로 존재하는 것이 아니다.

(`도메인(domain)` 개념은 나중에 정의하자. 지금 내가 할 수는 없을 것 같다.)

## 객체의 자율성

이전에도 설명했지만  

> 인스턴스 변수의 가시성은 `private`

> 메서드의 가시성은 `public`

클래스를 사용할 때 가장 중요한 것은 경계를 구분 짓는 것이다.  
즉 어떤 부분은 공개하고 어떤 부분 감출 것인지 결정하는 것인데  
이는 객체의 직접적인 접근을 막을 수 있고  
그 말은 객체의 자율성을 보장 할 수 있다.  

객체는 상태(state)와 행동(behavior)을 묶인 것으로 `캡술화`라고 부른다.  
이런 캡슐화에 접근을 통제할 수 있는게 `접근 제어(access control)`이고 대부분의 객체지향 프로그래밍은 이를 제공하는 `접근 수정자(access modifier)`를 제공한다.  

외부에서 접근이 가능한 부분을 `퍼블릭 인터페이스(public interface)`  
접근 불가능한 부분을 `구현(implementation)`

이런 객체지향 원칙을 지켜야 한다.  


## 협력하는 객체

영화가 상영될 때의 정보인 `상영`을 정의하면
```java
class 상영 {
  private 영화;
  private 순번;
  private 시간;

  public 예약하다(예매자, 인원수) {
    return new 예약(예메자, this, 요금을_계산하다(인원수), 인원수);
  }

  private 요금을_계산하다(인원수) {
    요금 = 영화.영화요금을_계산하다(this);
    return 요금.곱하다(인원수);
  }
}
```

전 장에서 돈과 관련된 부분은 생략되었는데 여기서는 돈을 명시하여 구체화 하였다.  
이하 요금과 관련된 명칭 다양하게 있을 예정인데 전부 `요금` 객체라고 생각하면 되겠다. 이는 스크립트를 단순화 하기 위한 구현 생략이라고 판단된다.
```java
class 요금 {
  public static final ZERO = 요금.원(0);

  private final 금액;

  public static 원(금액);

  public 곱하다(돈));

  public 뺀다(돈);

}
```

(`static`은 나중에 다시 확인하자. 일단은 객체가 어딘가에 있어서 그냥 사용가능)

```java
class 예약 {
  private 예매자;
  private 상영;
  private 요금;
  private 인원수;
}
```

영화를 예매하기 위해 각 인스턴스들이 서로의 메소드를 호출하며 상호작용을 한다.  

이런 상호작용을 `협력(collaboration)` 이라고 한다.

# 협력

객체는 다른 객체의 공개된 인터페이스를 통해 `요청(request)`할 수 있다.  
요청받은 객체는 이를 처리하고 `응답(response)`한다.  
이것이 협력의 기본이다.  

자주 나오는 말 중 하나가  

> 메시지와 메서드를 혼동하지 말아라

`메시지(message)`는 전송하거나 수신하여 객체가 어떻게 처리할지를 결정하게 하고  
수신된 메시지를 처리할 자신만의 방법이 `메서드(method)`가 된다.

이런 메시지와 메서드를 구분하는 것이 객체지향을 유연하고 확장 가능하며 재사용이 가능하게 만든다.  
이런 개념에서 부터 `다형성(polymorphism)`의 개념이 출발한다.


# 상속과 다형성

이제 할인은 구현해보자.

```java
class 영화 {
  private 제목;
  private 러닝타임;
  private 요금;
  private 할인정책;

  public 요금을_게산하다(상영) {
    금액 = 할인정책.요금을_할인하다(상영);
    return 요금.뺀다(금액);
  }
}
```

영화 객체의 메소드를 보면 요금을 계산하지만 어떤 할인 정책을 선택하는지 보이지 않는다.  
단지 `할인 정책`에 메시지를 전달할 뿐이다.  

## 할인 정책

두 가지 할인 정책(금액 할인 정책, 비율 할인 정책)은 대부분은 유사하고 할인 요금을 계산하는 방식만 조금 다른다.  

그래서 부모 클래스인 `할인정책` 안에 중복 코드를 두고 `금액할인정책`과 `비율할인정책`이 상속 받는다.  

이런 `할인정책`은 인스턴스를 생성할 필요가 없기 때문에 `추상 클래스(abstract class)`로 구현한다.

```java
abstract class 할인정책 {
  private List<할인조건> 조건들;

  public 요금을_할인하다(상영) {
    for (조건들) {
      if (조건.만족하면(상영)) {
        return 할인된_요금은(상영);
      }
    }

    return 요금.ZERO;
  }

  abstract protected 할인된_요금은(상영);
}
```

`할인정책`은 할인조건을 여러개 가질 수 있다.  
`할인조건`을 만족하면 해당 `요금`을 얻을 수 있다.  
주목할 점은 `추상 메서드`를 호출하여 할인 요금을 계산한다.  

전체흐름은 부모 클래스(할인정책)이 정의하지만 실제 요금을 계산하는 것은 추상 메서드(할인된_요금은)가 될 것이고 이는 부모 클래스를 상속받아 오버라이딩한 자식 크래스(금액할인정책, 비율할인 정책)의 메서드가 실행될 것이다.

할인조건은 인터페이스로 선언해보자.  
```java
interface 할인조건 {
  만족하면(상영);
}
```

그러면 조건들이 만족하는지 확인할 수 있는 인터페이스를 사용할 수 있다.

```java
class 순서조건 implements 할인조건 {
  private 순번;

  public 만족하면(상영) {
    return 상영.이번_순번인가(순번);
  }
}
```

```java
class 기간조건 implements 할인조건 {
  private 요일;
  private 시작시간;
  private 끝시간;

  public 만족하면(상영) {
    return 요일에_시작시간과_끝시간_사이면;
  }
}
```

`할인조건`을 사용하면서 `만족하면(상영)` 메서드를 구현했다.  
여기서 할인조건은 조건으로 이번 상영이 할인이 되는지 아닌지를 판단하는 객체이다.  
요금에 해당하는 것이 아니다. 햇갈리면 안되겠다.  

할인정책을 구현하자
```java
class 금액할인정책 extends 할인정책 {
  private 금액할인;

  public 할인된_요금은(상영) {
    return 금액할인;
  }
}
```

```java
class 비율할인정책 extends 할인정책 {
  private 할인율;

  public 할인된_요금은(상영) {
    return 상영.영화요금은().곱하다(할인율);
  }
}
```
`할인정책`을 상속받아서 할인된 요금을 구현했다.  
돈과 관련된 할인하는 값(금액할인, 할일율)은 `요금` 객체로 구현한다.  

위로 올라가 `영화` 객체를 확인하면  
영화당 하나의 `할인정책`을 받는다.  
그리고 `할인정책`의 `조건들` 변수를 통해서 복수 할인 조건을 넣을 수 있다.  

그래서 예제(아바타, 타이타닉, 스타워즈)를 구현하면

```java
영화 아바타 = new 영화('아바타', 120분, 요금.원(10000),
  new 금액할인정책(
    요금.원(800),
    new 순서조건(1),
    new 순서조건(10),
    new 기간조건(월요일, 10시, 12시),
    new 기간조건(목요일, 20시, 24시)
  )
);

영화 타이타닉 = new 영화('타이타닉', 180분, 요금.원(11000),
  new 비율할인정책(
    0.1,
    new 기간조건(화요일, 14시, 17시),
    new 순서조건(2),
    new 기간조건(목요일, 10시, 14시)
  )
);

영화 스타워즈 = ?
```

스타워즈는 잠시 넘어가고  

상속을 확인하자.

## 상속

상속은 부모 클래스의 모든 인터페이스를 자식 클래스가 물려받아 사용할 수 있다.  
즉 외부 객체는 자식 클래스를 부모 클래스와 동일하게 간주할 수 있다.  

`영화`의 `요금을_게산하다`을 보면 `할인정책`의 `요금을_할인하다` 인터페이스만 구현되어 있다면 어떤 객체와 상관없이 협력할 수 있다.  
즉 부모 클래스의 인터페이스를 물려받으면 자식 클래스를 부모 클래스로 간주한다.  

> 자식 클래스가 부모 클래스를 대신하는 것을 `업케스팅(upcasting)`이라 부른다.


## 트레이드 오프

아바타와 타이타닉은 조건문이 없는데도 어떻게 할인을 계산할 수 있을까?  

`요금정책`은 부모클래스로 자식클래스인 `금액할인정책`과 `비율할인정책`사이에 의존성이 존재한다. 그래서 요금을 계산할 때(할인된_요금은(상영)) 해당 객체의 구현을 사용한다.  

중요한 점은  

코드 수준에서 `영화`는 `할인정책`의 자식클래스 중에 어느 것에도 의존하지 않는다.  
오직 추상 클래스인 `할인정책`에만 의존한다.  
실제 동작하는 동안에 인스턴스 `금액할인정책`이나 `비율할인정책`에 의존한다.

> 코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다.

여기서 정리해야할 부분은  
코드의 의존성과 실행 시점의 의존성이 다르면  
> 코드가 유연해짐
> 쉽게 재사용 가능
> 확장 가능
반면에  
> 코드를 이해하기 어려워진다.
코드를 이해하기 위해서 코드뿐만 아니라 객체를 생성하고 연결하는 부분까지 찾아야 하기 때문이다.

즉 `트레이드 오프`를 해야한다.

> 무조건 유연한 설계도, 무존건 읽기 쉬운 코드도 정답이 이니다.

## 다형성

다형성은 메시지와 메서드를 구분하는 것 부터 시작한다고 말했다.  
그래서 메시지와 메서드를 정의한 것을 다시 보면  

> 메시지는 인스턴스에게 전송하여 어떻게 처리할지 결정하게 하는 것
> 메서드는 메시지를 처리하는 자신만의 방법

`영화`는 동일한 메시지를 전송하지만  
실제 메시지를 수행하는 객체는 클래스가 무엇이냐에 따라 달라진다.  
이것을 `다형성`이라고 한다.

> 다형성 : 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력

`영화`클래스느 추상클래스 `할인정책`에 의존한다.  
그러나 실제로 상호작용하는 객체는 `금액할인정책`이나 `비율할인정책`의 인스턴스다.  

> 다형성은 컴파일 시간 의존성과 실행 시간 의존성을 다르게 만들 수 있는 객체지향의 특성을 이용해 서로 다른 메서드를 실행할 수 있게 한다.

## 다형성의 컴파일 시점과 실행 시점

메시지 응답을 위해 실행될 메서드를 실행 시점에 결정하면 - 메서드를 실행 시점에 바인딩 하면

> `지연 바인딩(lazy binding)` 또는 `동적 바인딩(dynamaic binding)`

전통적인 함수 호출처럼 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을

> `초기 바인딩(early binding)` 또는 `정적 바인딩(static binding)`

객체지향은 `지연 바인딩`을 사용한다.


# 추상화

여기서 추상적인 개념으로 사용한 것은 `할인정책`과 `할인조건`이다.

`할인정책`은 추상 클래스를 사용했고
`할인조건`은 인터페이스를 사용했다.

프로그래밍 언어 측면에서 `할인조건`이 `할인정책`이 더 추상적이다.  
둘다 자식 클래스가 공통으로 가질 수 있는 인터페이스를 정의할 수 있는 결정권을 위임한다. 하지만 인터페이스가 인터페이스에 더 초점을 맞추기 때문이다.  

그렇다면 추상화는 좋은 것인가?

추상화의 장점을 보자.

> 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있다.
> 협력 호름을 기술할 수 있다.
> 재사용 가능한 설계의 기본을 이루는 `디자인 패턴(design pattern)`이나 `프레임워크(framework)` 모두 추상화를 이용한다.


# 유연한 설계

아까 정의하지 않은 스타워즈를 다시 보자.

`영화` 스타워즈는 할인 정책이 적용돼 있지 않다.  
이런 "할인 정책이 없는 경우"는 예의 케이스로 취급하기 때문에 지금까지 일관성 있던 협력 방식이 무너지게 된다.

이런 예외 경우를 적용하기 위해서 `조건문`을 사용하는 겻은 설계 측면에서 좋지 않은 선택이다. 

> 항상 예외 케이스를 최소화하고 일관성을 유지하라

```java
class 할인없는정책 extends 할인정책 {
  protected 요금을_할인하다(상영) {
    return 요금.ZERO;
  }
}
```

`할인정책`을 상속받는 `할인없는정책`을 구현하면 일관성있는 설계를 할 수 있다.

```java
영화 스타워즈 = new 영화("스타워즈", 210분, 요금.원(10000),
  new 할인없는정책());
```

이렇게 추상화를 중심으로 설계하면 확장 가능하게 설계가 가능하다.

# 추상 클래스와 인터페이스 트레이드 오프

`할인정책`을 다시 살펴보자. `요금을_할인하다(상영)`는 `할인조건`이 없으면 `할인된_요금은(상영)`을 실행하지 않고 `요금.ZERO`를 반환한다. 이는 `할인정책`에 `할인없는정책`의 개념이 포함되어 있는 설계이다.  
그래서 이를 더 명확히 수정해본다.

```java
interface 할인정책 {
  요금 요금을_할인하다(상영);
}
```
`할인정책`에 있던 `요금을_할인하다(상영)`를 인터페이스로 수정했다.

그러면 기존의 `할인정책`을 `기본할인정책`으로 수정해야 한다.
```java
abstract class 기본할인정책 implements 할인정책 {
  ...
}
```

`할인없는정책`은 `할인정책`을 사용하여 수정할 수 있다.
```java
class 할인없는정책 implements 할인정책 {
  public 요금을_할인하다(상영) {
    return 요금.ZERO;
  }
}
```

그리고 기존 `할인정책`(지금은 `기본할인정책`)을 상속받던 `금액할인정책`과 `비율할인정책`은 `기본할인정책`을 상속받도록 수정하면 되겠다.

이제 다시 살펴보자

`할인없는정책`을 위해 `할인정책`을 인터페이스로 바꾸고 다른 클래스들도 수정되는 것이 과하게 느껴질 수도 있지만  

> 이상적으로는 인터페이스를 사용하도록 변경한 설계가 더 좋을 것이다.

어쨌든 0원을 효과적으로 전달하는 것은 사실이다.

구현과 관련된 모든 설계는 트레이드 오프의 대상이 될 수 있다는 것을 알아두자.

# 상속과 합성

> 합성은 다른 객체의 인스턴슬르 자신의 인스턴스 변수로 포함해서 재사용하는 방법이다.

`영화`에서 `할인정책`을 합성으로 사용하고 있다.  
이 설계를 상속으로 사용할 수도 있는데  
`할인정책`에서 `영화`를 직접 상속받아 `금액할인영화` 또는 `비율할인영화` 클래스를 추가하면 기존의 방법과 기능적으로 동일한다.  
그런데도 상속보다 합성을 선호하는 이유는 무엇일까?

## 상속

> 상속은 캡슐화를 위반한다

부모 클래스의 구현이 자식 클래스에게 그대로 노출되기 때문에 캡슐화가 약하게 된다.  
부모 클래스가 변경될 때 자식 클래스도 변경될 확율이 높아진다.  
즉 코드 변경이 어려워진다.  

> 설계를 유연하지 못하게 만든다

부모 클래스와 자식 클래스 사이의 관계가 컴파일 시점에서 결정된다. 이러면 실행 시점에 객체의 종류를 변경하기 힘들어진다.  
하지만 인스턴스 변수를 사용하면 그냥 새로운 `할인정책`을 넣어주면 간단히 해결된다.  
즉 상속보다 합성이 더 유연한 설계가 가능한다.

## 합성

`영화`에서 `할인정책`은 인터페이스를 통해 약하게 결합된다. 그래서 `영화`는 `할인정책`이 `요금을_할인하다(상영)` 말고는 내부 구현을 알지 못 한다.  

> 합성 : 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법

이런 합성은 상속의 문제를 모두 해결한다.  
따라서 코드 재사용을 위해 상속보다는 합성을 선호하는 것이 더 좋은 방법이다.  

> 그렇다고 해서 상속을 정대 사용하지 말라는 것은 아니다.

대부분의 설계는 상속과 합성을 함께 사용한다.  
`할인정책`을 상속받는 `금액할인정책`과 `비율할인정책`처럼 다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 합께 사용할 수 밖에 없다.

