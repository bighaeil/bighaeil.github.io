---
title: "MySQL 스터디 4일차 - index"
categories:
    - db
    - mysql
    - index
last_modified_at: 2023-06-07T22:00:00
toc: true
---

인덱스는 데이터베이스 쿼리의 성능에 중요한 부분이다

쿼리 성능은 디스크에서 데이터를 가져오거나 쓰는 행위를 줄여주는 것을 의미한다

그래서 디스크 I/O를 잠시 알아보자

디스크 I/O는 컴퓨터에서 가장 느린 부분이다

디스크에는 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)가 있다

SSD는 HDD보다 랜덤 I/O가 휠씬 빠르다

데이터베이스 서버에서 순차 I/O 작업보다 랜덤 I/O를 통해 데이터를 읽고 쓴느 작업이 데부분이다
그래서 SSD가 DBMS 스토리지에 최적이다

랜덤 I/O는 보통 디스크(원판)에 헤더를 원하는 위치에 이동하는 것을 의미한다 그런데 그 위치가 물리적으로 불연속으로 헤당 위치로 움직여야 한다

순차 I/O는 랜덤 I/O처럼 이동하는 것은 같지만 데이터가 연속적이여서 그대로 쭉 읽으면 된다

일반적으로 쿼리 튜닝하는 것은 이런 랜덤 I/O 자체를 줄이는 것을 목적으로 한다

즉 쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 쿼리를 개선한다

# 인덱스

인덱스는 색인이라는 의미로 DB에서는 해당 레코드가 저장된 주소와 데이터를 빠르게 찾을 수 있도록 만들어 두는 것이다

DBMS의 인덱스는 값으로 항상 정렬된 상태를 유지한다

그래서 INSERT, UPDATE, DELETE에는 처리가 느리지만 정렬된 인덱스는 SELECT가 빠르게 처리된다

그래서 WHERE 조건절에 사용하는 칼럼을 전부 인덱스로 생성하면 저장 성능이 떨어지고 인덱스가 비대해져 성능이 떨어진다

인덱스를 역할별로 구분

- 프라이머리 키(Primary key), 레코드를 대표하는 칼럼 값으로 만들어진 인덱스, NULL 값을 허용하지 않고 중복을 허용하지 않는다

- 프라이머리 키를 제외한 나머지 모든 인덱스 보조 키(Secondary Index)

인덱스를 알고리즘으로 구분

- B-Tree 알고리즘, 일반적으로 사용, 값을 변형하지 않고 그대로 인덱싱

- Hash 인덱스 알고리즘, 값을 해시값으로 인덱싱, 빠른 검색을 지원, 값이 변행되므로 부분 검색 사용할 수 없음, 주로 메모리 기반의 데이터베이스에서 사용

## B-Tree 인덱스

일반적으로 사용

B는 Balanced를 의미

원래 값을 변형시키지 않음

항상 정렬된 상태로 유지

### 구조 및 특징

트리 구조로 최상위 하나의 루트 코드(Root node)가 존재

가장 하위에 있는 노드를 리프 노드(Leaf node), 중간의 노드를 브랜치 노드(Beanch node)라 한다

인덱스는 정렬되어 있지만 레코드는 정렬되지 않는다

리프 노드의 데이터 파일은 저장된 레코드의 주소를 가진다

InnoDB 스토리지 엔진은 레코드를 읽기 위해서

검색어를 인덱스 키로 하고 프라이머리 키를 값으로 하는 B-Tree 인덱스를 검색하고

검색어를 프라이머리 키로 하고 레코드를 값으로하는 B-Tree 인덱스를 다시 검색하는 구조를 하고 있다

#### 인덱스 키 추가

인덱스를 추가하려면 리프 노드를 추가해야 하는데 해당 리프 노드가 꽉 차서 더는 저장할 수 없으면 분리(Split)해야 한다 이는 상위 브랜치 노드까지 처리 범위가 넓어지기 때문에 비용이 많이 든다

#### 인덱스 키 삭제

삭제는 해당 키 값이 저장된 리프 노드를 그냥 삭제하면 된다

#### 인덱스 키 변경

변경은 값이 변경되어 해당 리프 노드 위치가 변경되야 한다

변경 작업은 먼저 키를 삭제하고 변경된 값을 추가 한다

#### 인덱스 키 검색

검색은 로트 노드부터 시작하여 브랜치 노드를 거쳐 리프 노드까지 이동하는 작업을 한다 이를 트리 탐색 이라 한다

### 영향

인덱스 사용에 영향을 주는 요소

#### 인덱스 키 값의 크기

InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지(Page) 또는 블록(Block)이라 한다

즉 디스크 읽기, 쓰기 작업의 최소 작업 단위가 된다

페이지는 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이다

그래서 인덱스도 페이지 단위로 관리된다

그래서 B-Tree의 자식 노드를 몇 개까지 가지는지 페이지 크기에 따라 결정된다

B-Tree의 B는 binary 가 아니다 즉 여러 자식 노드를 가질 수 있다

인덱스를 구성하는 키 값이 커지면 디스크로 부터 읽는 횟수가 늘어나고 그만큼 느려진다

#### 깊이

깊이(Depth)는 제어할 수 없다

하지만 인덱스 키 값의 크기가 깊이에 영향을 미친다

인덱스 키 값이 커지면 페이지에 담을 수 있는 인덱스 키 값의 개수가 적어지기 때문에 깊이가 깊어진다

#### 선택도(기수성)

선택도(Selectivity) 또는 기수성(Cardinality)는 유니크한 값의 수를 의미한다

전체 인덱스 키 값이 100개에서 유니크한 값이 10개라면

기수성은 10 이다

중복된 값이 많아지면 기수성은 낮아지고 선택도는 떨어진다

선택도가 높을 수록 검색 대상이 줄어들기 때문에 빠르게 처리한다

#### 읽어야 하는 레코드 수

만약 거의 모든 테이블을 읽어야 한다면 인덱스를 거치는 것 보다 직접 레코드를 읽는 것이 효율적이다

즉 인덱스를 이용할지 직접 읽을지 판단해야 한다

인덱스를 통해 읽어야할 레코드 수가 전체 테이블 레코드의 20 ~ 25% 면 인덱스를 이용하지 않고 테이블을 직접 읽는 것이 효율적이다

### 인덱스를 통해 데이터 읽기

#### 인덱스 레인지 스캔

대표적인 접근 방식

조건에 만족하는 값이 저장된 위치를 찾는다(인덱스 탐색) 검색해야 할 인덱스의 범위가 결정됐을 때 리프 노드의 레코드만 순서대로 읽는다(인덱스 스캔)

#### 인덱스 풀 스캔

인덕스를 처음부터 끝까지 읽는 방식

인덱스 테이블의 크기가 테이블의 크기보다 작으므로 효율적이다

#### 루스 인덱스 스캔

느슨하게 듬성듬성 인덱스를 읽는 방식

필요하지 않는 인덱스를 스킵

일반적으로 GROUP BY 나 집합 함수 중 MIN(). MAX() 등에 최적화할 수 있다

인덱스 값으로 이미 정렬되어 있기 때문에

#### 인덱스 스킵 스캔

```sql
... ADD INDEX ix_name (a, b);
```

8.0 부터 옵티마이저가 핵심 인덱스의 칼럼(a)이 없이 서브 칼럼(b)만 으로 검색해도 알아서 스캔한다

하지만 제약이 존재한다

핵심 인덱스의 유니크한 값의 수가 적어야 한다 왜냐면 유니크 수가 많다면 옵티마이저가 스캔해야 할 시작 지점이 많아진다 즉 처리 속도가 느려진다

쿼리가 인덱스가 존재하는 칼럼만으로 처리가 가능해야 한다

### 다중 칼럼 인덱스

두 개 이상 칼럼이 포함된 인덱스

인덱스의 다음 칼럼은 앞의 칼럼에 의존하여 정렬된다

그래서 인덱스 내에 칼러의 순서가 중요하다

### 정렬 및 방향

#### 정렬

인덱스를 생성하는 시점에 설정

8.0 부터 정렬 순서를 혼합하여 인덱스를 생성할 수 있다

#### 방향

인덱스는 항상 오름차순으로 정렬되어 있다

만약 최소값부터 읽으려면 거꾸로 읽는 방식을 사용한다

#### 성능

역순으로 스캔하는 것이 정순으로 스캔하는 것보다 더 느리다

이유는

인덱스가 정순 스캔에 더 적합한 구조이고

페이지 내에 인덱스 레코드가 단방향으로 연결된 구조이기 때문이다

### 효율성

쿼리에 WHERE 절이나 GROUP BY 절이나 ORDER BY 절이 있으면 인덱스를 사용할 수 있으니 어떻게 사용되는지 알 수 있어야 한다

동등 동등 비교(=)나 크다(>) 작다(<) 에 따라 효율이 달라진다

```sql
... WHERE a='ABC' AND b > 100;
```

```sql
INDEX ix_a (a, b);
```

```sql
INDEX ix_b (b, a);
```

ix_a 의 경우 a 를 동등 비교로 찾고 아래로 쭉 b 조건까지만 스캔하여 효율적이다

ix_b 의 경우 b 를 찾고 모든 케이스에 대해서 a 조건을 하나씩 비교하기 때문에 비효율적이다

### 가용성

B-Tree 인덱스의 특징은 왼쪽 값에 기준해서 오른쪽 값이 정렬된다

그래서 왼쪽 값이 없으면 인덱스 레인지 스캔을 사용할 수 없다

그래서 특성상 다음 조건에서는 사용할 수 없다

- NOT-EQUAL로 비교된 경우
- LIKE "%ABC" 뒷부분 일치인 경우
- 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교하는 경우
- NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용되는 경우
- 데이터 타입이 서로 다른 비교
- 문자열 데이터 타입의 콜레이션이 다른 경우

다중 칼럼의 경우 사용할 수 없는 경우는 다음과 같다

- 왼쪽 칼럼에 대한 조건이 없는 경우
- 왼쪽 칼럼의 조건이 있지만 위에 조건에 해당하는 경우

