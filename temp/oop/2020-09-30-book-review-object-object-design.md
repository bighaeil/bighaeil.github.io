---
title: "CHEPTER 1 - object & design"
categories: 
  - oop
tags:
  - oop
  - object
  - design
  - review
last_modified_at: 2020-09-30T20:10:00+09:00
toc: true
toc_sticky: true
---

이하 내용은 도서 `오브젝트`를 읽고 나 나름대로 정리를 한 내용입니다.  


# 이론과 실무

IT 일을 하면서 느끼는 것 - 일 중심의 업무와 개발 중심의 업무에서 고민을 많이 한다.  

일 중심 - 아무래도 빨리 끝낼 수 있기 때문에  
개발 중심 - 테스트 코드, 리펙토링 등 의미없어 하는 회사들도 많다.  

하지만 책에서 가장 마음에 와닿는 말이 있었다.  

> 해당 분야가 충분히 성숙해지는 시점에 이르러서야 이론이 실무를 추월하게 된다.  

내가 일보다 "어떻게 만들까"에 집중하게된 이유는 아마도  
이론이 충분히 성숙되는 것이 일의 효율성 영향을 주는 것을 느끼게 되어서  
즉 일을 덜 힘들게 할 수 있다.  

충분한 이론이 밑바탕에 있어야 더 효율적으로 일하게 된다는 사실을 알게 되었다.  

# 실무 설계

티켓 판매를 예로 객체지향 설계를 알아보자.


## 티켓 판매

티켓을 판매하는 상황

티켓이 있겠고
```java
class 티켓 {
  private 가격
}
```

관람객이 있겠다.
```java
class 관람객 {
  private 가방
}
```

관람객은 가방에는 돈, 초대장, 티켓이 있겠다.  
```java
class 가방 {
  private 돈
  private 초대장
  private 티켓

  public 초대장이_있으면()
  public 초대장을_준다()
  public 돈을_지불()
  public 티켓을_받음()
}
```

티켓을 살 수 있는 매포소에는
```java
class 매표소 
  private 돈
  private 티켓바구니

  public 돈을_수납()
  public 티켓을_지급()
```

매표소에는 판매원이 일을 하고 있다.
```java
class 판매원
```

그래서 극장에서는 이런 일이 일어난다.
```java
class 극장 {
  private 판매원

  public 입장(관람객)  {
    if (관람객.가방.초대장이_있으면()) {
      관람객.가방.초대장을_준다();
    } 
    else {
      관람객.가방.돈을_지불();
      판매원.매표소.돈을_수납();
      판매원.매표소.티켓을_지급();
      관람객.가방.티켓을_받음();
    }
  }
}
```

위 객체는 잘 동작하는 것처럼 보이고 실제로도 동작은 잘(?) 할 것이다.  
하지만 객체지향적으로 볼때 아래와 같은 문제가 있다.  


### 수동적인 존재

> 관람객과 판매원은 소극장의 통제를 받는 수동적인 존재

모든 일은 극장에서 일어난다. 그런데 무엇이 문제인가?  
관람객과 판매원의 의사와 상관없이 돈을 빼고 티켓을 준다.  
수동적인 존재의 원인으로  
하나의 메서드에서 너무 많은 일이 일어난다.  
이런 코드는 코드를 더 이해하기 어렵게 만든다.  


### 변경에도 취약한 코드

관람객이 가방이 아니라 지갑을 꺼낸다면?  
돈이 아니라 카드로 지불한다면?  
객체를 변경하면 수정해야 될 부분들이 너무 많다.  

객체 사이의 관계가 얼마나 긴밀하게 연결되어 있는가를  

> 객체 사이의 의존성(dependency)

이라고 한다.

의존성이 과한 경우 `결합도(coupling)`가 높다고 말한다.  

객체 사이의 의존선을 없애라는 말이 아니고  
객체지향 설계에 객체간의 의존성을 생각하면서 `협력`하게 만들라는 것  


## 개선

관람객과 판매원을 자율적인 존재로 만든자.

먼저 판매원이 자율적으로 판매를 할 수 있도록 해보자.
```java
class 판매원 {
  private 매표소

  public 판매한다(관람객) {
    if (관람객.가방.초대장이_있으면()) {
      관람객.가방.초대장을_준다();
    } 
    else {
      관람객.가방.돈을_지불();
      매표소.돈을_수납();
      매표소.티켓을_지급();
      관람객.가방.티켓을_받음();
    }
  }
}
```

```java
class 극장 {
  private 판매원

  public 입장(관람객)  {
    판매원.판매한다(관램객);
  }
}
```

이거 극장에서 판매원으로 코드만 이동한 것 아니야?  
판매원만 고생하게 생겼네 라고 생각할 수 있지만  

매표소를 확인해보자.  
이제 매표소는 판매원 외에는 누구도 확인할 수 없다.  
악의적으로 매표소를 털거나 티켓을 훔치거나 할 수 없다.  
(판매원이 사기치지 않는 이상)  
즉 제 3자가 매표소를 이렇게 저렇게 할 수 없다는 의미이다.  

> 이처럼 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 `캡슐화(encapsulation)`라 부른다.  

극장 입장에서 보면  

극장은 오직 판매원의 `판매한다()`를 통해 메시지를 이해하고 응답할 수 있다.  
즉 극장이 보는 판매원의 `판매한다()`는 `인터페이스(interface)`이다.  

그리고 판매원의 `판매한다()`에서 매표소는 실제 구매를 하는 `구현(implementation)` 영역에 속한다.  

> 객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드로 만든다.

그리고 매표소는 분명 존재하고 동작하지만 극장은 매표소의 존재를 알 수 었다.  

일단은 객체를 자율적인 존재로 만들었다.  
