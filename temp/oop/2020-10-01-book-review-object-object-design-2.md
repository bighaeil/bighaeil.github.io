---
title: "CHEPTER 2 - object & design 2"
categories: 
  - oop
tags:
  - oop
  - object
  - design
  - review
last_modified_at: 2020-10-01T20:00:00+09:00
toc: true
toc_sticky: true
---

이하 내용은 도서 `오브젝트`를 읽고 나 나름대로 정리를 한 내용입니다.  


# 이론과 실무

이전 포스트에 이어서 객체지향 설계를 계속해보자.  

기존 코드
```java
class 판매원 {
  private 매표소

  public 판매한다(관람객) {
    if (관람객.가방.초대장이_있으면()) {
      관람객.가방.초대장을_준다();
    } 
    else {
      관람객.가방.돈을_지불();
      매표소.돈을_수납();
      매표소.티켓을_지급();
      관람객.가방.티켓을_받음();
    }
  }
}
```

```java
class 관람객 {
  private 가방

  public 뭐가있지()
}
```


## 판매자와 관람객의 자율성

판매원과 관람객의 자율성을 높인다.  
```java
class 판매원 {
  private 매표소

  public 판매한다(관람객) {
    티켓 = 매표소.티켓을_지급();
    가격 = 관람객.지불(티켓);
    매표소.돈을_수납(가격);
  }
}
```

```java
class 관람객 {
  private 가방

  public 지불(티켓) {
    if (가방.초대장이_있으면()) {
      가방.초대장을_준다();
      return 0원;
    } 
    else {
      가방.돈을_지불();
      가방.티켓을_받음();
      return 티켓.가격;
    }
  }
}
```

판매원은 판매하는 목적에만 집중하고  
관람객은 해당 티켓에 대한 처리만 책임진다.  

즉 판매원은 관람객의 `인터페이스`에만 의존한다.

- 판매원 - 매표소의 돈과 티켓을 관리한다.  
- 관람객 - 자신이 가지고 있는 소지품을 스스로 관리한다.  

> 자기 자신의 문제를 스스로 해결하도록 코드를 변경


# 캡슐화와 응집도

객체의 내부의 상태를 캡슐화하고 응집도를 낮춘다 - 객체 간에 오직 메시지를 통해서만 상호작용 하도록 만드는 것  

즉 `응집도`라는 애매모호한 말은  

> 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 것

이라고 정의할 수 있겠다.  


# 절차지향과 객체지향

절차지향 : 순서대로 처리되는 프로세스 - 데이터에 의존할 수 밖에 없음 - 데이터 중심으로 순서대로 처리하는 것

객체지향 : 자신의 데이터를 스스로 처리하는 프로세스

이렇게 정의 하면 마치 객체지향이 훨씬 좋은 것 처럼 보여지지만  
객체지향이 코드를 더 유연하게 만드는 것이고  
절차지향은 응집도 내부에서 적절하게 사용되여 진다고 생각하자.  
(마치 결제시 전지적 누군가에 의해 "이제부터 결제를 시작하겠습니다. 데이터를 주시지요."하는 것 처럼 보이지만 - 이렇게 보면 절차적 프로그래밍이 망나니처럼 보인다.)  


## 책임의 이동 - shift of reponsibility

결국 두 방식 사이의 근본적인 차이는 `책임의 이동`  

> 각 객체는 자신을 스스로 책임진다.

이것만 기억하면 될 것 같다.


# 가방과 매표소

그렇다면 가방도 역시 객체인데 가방에도 자율성을 넣을 수 있는 것 아닌가?
```java
class 가방 {
  private 돈
  private 초대장
  private 티켓

  public 꺼낸다(티켓) {
    if (초대장이_있으면()) {
      //초대장을_사용;// 초대장까지 처리하진 않음
      티켓을_넣는다(티켓);
      return 0원;
    } 
    else {
      티켓을_넣는다(티켓);
      돈을_지불(티켓.가격);
      return 티켓.가격;
    }
  }

  private 초대장이_있으면();
  private 티켓을_넣는다(티켓);
  private 돈을_지불(가격);
}
```

가방의 구현을 캡슐화했으니 관람객은 가방의 인터페이스에 의존한다.  
```java
class 관람객 {
  private 가방

  public 지불(티켓) {
    가격 = 가방.꺼낸다(티켓);
    return 가격;
  }
}
```

매표소 역시 자율권을 줘보자.
```java
class 매표소 
  private 돈
  private 티켓바구니

  public 티켓을_판매하는_장소_입니다(관람객) {
    가격 = 관람객.지불();
    돈을_담는다(가격);
  }

  private 티켓바구니에서_티캣을_꺼낸다()
  private 돈을_담는다(가격);
```

이러면 판매원은 매표소의 인터페이스에 의존한다.
```java
class 판매원 {
  private 매표소

  public 판매한다(관람객) {
    매표소.티켓을_판매하는_장소_입니다(관람객);
  }
}
```

이렇게 관람객과 가방, 매표소와 판매원에 의존성이 추가되었다.

변경된 부분을 살펴보자.  
처음 매표소는 관람객의 존재를 모르고 있었다(의존성이 없었다).  
그러다가 책임을 주면서 매표소는 관람객의 존재를 알아야만 했고  
그래서 의도하지 않은 결합도가 높아졌다.  

> 매표소의 자율성은 높아졌지만 전체 설계의 관점에서는 결합도가 상승했다.


## 트레이드 오프

위 예제를 보면   
각 객체에 책임을 주기위해 각 자율성을 높였다.  
그러면서 어느 영역에서 의존성이 생겼버렸다.  
즉 동일한 기능을 구현하는 방법은 다양하다.  
다시 말하면  

> 어떤 경우에도 모든 사람들을 만족시킬 수 있는 설계를 만들 수 없다.

즉 설계를 할때 어떤 부분에 중요도를 줄 것인지 명확히 해야할 필요가 있다.


# 무생물

매표소와 가방은 무생물이다.

팬매원과 관람객은 사람 - 사람은 무언가 책임을 지고 행동하는 것은 자연스럽다. 자연스럽게 연상된다.  
설계에서는 매표소와 가방은 각자의 책임을 가지고 있고 그렇게 행동한다. 마치 `의인화(anthropomorphism)`화여 설계된다.  

> 그 대상이 비록 실세계에서는 생명이 없는 수동적인 존재라고 하더라도 객체지향의 세계로 넘어오는 순간 그들은 생명과 지능을 가진 싱싱한 존재로 다시 태어난다.

필요하다면 무생물에도 주체적으로 움직이도록 자연스럽게 생각하자.  


# 결론

객체지향 설계를 하면서 코드가 유연하게  
즉 객체를 자율적이고 책임을 가진 그리고 협력하도록 설계할 수 있다.  
